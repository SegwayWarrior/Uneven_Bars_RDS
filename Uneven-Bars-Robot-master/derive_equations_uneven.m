%% derive_equations_uneven.m

function derive_equations_uneven
clear all;
close all;
clc;

fprintf('Deriving cart-pendulum equations...\n');

%% Define generalized variables
fprintf('\tInitializing generalized coordinates, velocities, accelerations, and forces...\n');

% Generalized coordinates:
% x: x-location of gripper
% y: y-location of gripper
% theta_1: angle of top link, ccw+ wrt x-axis
% theta_2: angle of mid link, ccw+ wrt top link
% theta_3: angle of bot link, ccw+ wrt mid link

syms  x y theta_1 theta_2 theta_3 real
q = [x; y; theta_1; theta_2; theta_3];

% Generalized velocities:
% dx: first derivative of x-location of gripper wrt time
% dy: first derivative of y-location of gripper wrt time
% dtheta_1: first derivative of top link angle wrt time
% dtheta_2: first derivative of mid link angle wrt time
% dtheta_3: first derivative of bot link angle wrt time
syms dx dy dtheta_1 dtheta_2 dtheta_3 real
dq = [dx; dy; dtheta_1; dtheta_2; dtheta_3];

% Generalized accelerations:
% ddx: second derivative of x-location of gripper wrt time
% ddy: second derivative of y-location of gripper wrt time
% ddtheta_1: second derivative of the top link angle wrt time
% ddtheta_2: second derivative of the mid link angle wrt time
% ddtheta_3: second derivative of the bot link angle wrt time
syms ddx ddy ddtheta_1 ddtheta_2 ddtheta_3 real
ddq = [ddx; ddy; ddtheta_1; ddtheta_2; ddtheta_3];

% Generalized forces:
Q = sym('Q', [1, numel(q)], 'real'); % Force vector on the triple pendulum
syms tau_shoulder tau_hip
Q = [0; 0; 0; tau_shoulder; tau_hip];

% the input should be 2*1 vector [u1;u2]
u = sym('u',[2,1],'real');

% S is the selection matrix, Q = Su;S is 5*2 matrix u is 2*1 matrix; Q is
% 5*1 matrix
S = [0,0;
     0,0;
     0,0;
     1,0;
     0,1];

fprintf('\t...done.\n');


%% Define kinematics variables
fprintf('\tInitializing kinematics variables...\n');

% x-coordinates of the top, mid, bot links CoM:
syms x_com_top x_com_mid x_com_bot real

% y-coordinates of the top, mid, bot links CoM:
syms y_com_top y_com_mid y_com_bot real

% Dimensions: distance joint to top, mid, bot link CoM:
syms r_com_top r_com_mid r_com_bot real

% Dimensions: length of the top, mid, bot link
syms l_top l_mid l_bot real

% x-coordinates of top, mid, bot tip:
syms x_tip_top x_tip_mid x_tip_bot real

% y-coordinates of top, mid, bot tip:
syms y_tip_top y_tip_mid y_tip_bot real

fprintf('\t...done.\n');

%% Define inertial (and other) parameters
fprintf('\tInitializing inertial (and other) parameters...\n');

% Mass of top, mid, bot link:
syms m_top m_mid m_bot m_motor1 m_motor2 real

% Rotational inertia of top, mid, bot link:
syms I_top I_mid I_bot real

% Viscous damping at each joint:
b = sym('b',[numel(q),1],'real');
% Note: we'll account for damping at each joint

% Other variables
g = sym('g','real'); % gravity
t = sym('t','real'); % time

fprintf('\t...done.\n');

%% Forward kinematics
fprintf('\tGenerating forward kinematics equations...\n');

% compute the (x,y) location of the top link's CoM:
x_com_top = x + r_com_top*sin(theta_1);
y_com_top = y - r_com_top*cos(theta_1);

% compute the (x,y) location of the top link's tip:
x_tip_top = x + l_top*sin(theta_1);
y_tip_top = y - l_top*cos(theta_1);

%compute the (x,y) location of the mid link's CoM:
x_com_mid = x_tip_top + r_com_mid*sin(theta_1+theta_2);
y_com_mid = y_tip_top - r_com_mid*cos(theta_1+theta_2);

%compute the (x,y) location of the mid link's tip:
x_tip_mid = x_tip_top + l_mid*sin(theta_1+theta_2);
y_tip_mid = y_tip_top - l_mid*cos(theta_1+theta_2);

%compute the (x,y) location of the bot link's CoM:
x_com_bot = x_tip_mid + r_com_bot*sin(theta_1+theta_2+theta_3);
y_com_bot = y_tip_mid - r_com_bot*cos(theta_1+theta_2+theta_3);

%compute the (x,y) location of the bot link's tip:
x_tip_bot = x_tip_mid + l_bot*sin(theta_1+theta_2+theta_3);
y_tip_bot = y_tip_mid - l_bot*cos(theta_1+theta_2+theta_3);

% create a 2x7 array to hold all forward kinematics (FK) outputs:
FK = [x_com_top, x_tip_top, x_com_mid, x_tip_mid, x_com_bot, x_tip_bot;
      y_com_top, y_tip_top, y_com_mid, y_tip_mid, y_com_bot, y_tip_bot];

% generate a MATLAB function to compute all the FK outputs:
matlabFunction(FK,'File','autogen_fwd_kin');
% Note: this autogenerated function will make plotting/animation easier
% later. Could also help with some control tasks.
fprintf('\t...done.\n');

%% Derivatives
fprintf('\tGenerating time derivatives of the kinematics equations...\n');
% Neat trick to compute derivatives using the chain rule
% from https://github.com/MatthewPeterKelly/OptimTraj/blob/master/demo/fiveLinkBiped/Derive_Equations.m
derivative = @(in)( jacobian(in,[q;dq])*[dq;ddq] );

% CoM x-velocities:
syms dx_com_top dx_com_mid dx_com_bot real
% CoM y-velocities:
syms dy_com_top dy_com_mid dy_com_bot real

dx_com_top = derivative(x_com_top); % x velocity top link
dy_com_top = derivative(y_com_top); % y velocity top link
dx_com_mid = derivative(x_com_mid); % x velocity mid link
dy_com_mid = derivative(y_com_mid); % y velocity mid link
dx_com_bot = derivative(x_com_bot); % x velocity bot link
dy_com_bot = derivative(y_com_bot); % y velocity bot link

% generate MATLAB functions for the Jacobians and Hessians:
matlabFunction(dx_com_top, dy_com_top,...
               dx_com_mid, dy_com_mid,...
               dx_com_bot, dy_com_bot,'File','autogen_jacobians');

fprintf('\t...done.\n');

%% Kinetic energy
fprintf('\tGenerating kinetic energy equation...\n');

syms ke_top ke_mid ke_bot KineticEnergy real

% kinetic energy of each link:
ke_top = (1/2)*m_top*(dx_com_top^2 + dy_com_top^2) + (1/2)*I_top*(dtheta_1^2); 
ke_mid = (1/2)*(m_mid + m_motor1 + m_motor2)*(dx_com_mid^2 + dy_com_mid^2) + (1/2)*I_mid*(dtheta_1^2 + dtheta_2^2);
ke_bot = (1/2)*m_bot*(dx_com_bot^2 + dy_com_bot^2) + (1/2)*I_bot*(dtheta_1^2 + dtheta_2^2 + dtheta_3^2);

% total kinetic energy:
KineticEnergy = ke_top + ke_mid + ke_bot;
matlabFunction(KineticEnergy,'File','autogen_kinetic_energy');
fprintf('\t...done.\n');
%% Potential energy
fprintf('\tGenerating potential energy equation...\n');

syms pe_top pe_mid pe_bot PotentialEnergy real

% potential energy of each link:
pe_top = m_top * g * y_com_top;
pe_mid = (m_mid + m_motor1 + m_motor2) * g * y_com_mid;
pe_bot = m_bot * g * y_com_bot;

%total potential energy:
PotentialEnergy = pe_top + pe_mid + pe_bot;

matlabFunction(PotentialEnergy,'File','autogen_potential_energy');
fprintf('\t...done\n');

fprintf('\tGenerating total energy...\n');

% Total Energy
syms Total_E real
Total_E =  PotentialEnergy + KineticEnergy;
matlabFunction(Total_E,'File','autogen_total_energy');
fprintf('\t...done.\n');

%% Lagrangian
fprintf('\tGenerating Lagrangian...\n');

syms L real
L = KineticEnergy - PotentialEnergy;

fprintf('\t...done.\n');

%% Euler-Lagrange equations
fprintf('\tGenerating Euler-Lagrange equations of motion...\n')

% Variable initializations:
dL_dqdot    = sym('dL_dqdot',[numel(q),1],'real'); % del L/del q_dot
dL_dqdot_dt = sym('dL_dqdot_dt',[numel(q),1],'real'); % d(del L/del dq)/dt
dL_dq       = sym('dL_dq',[numel(q),1],'real'); % del L/del q
EL_damping  = sym('EL_damping',[numel(q),1],'real');% joint damping
EL_LHS      = sym('EL_LHS',[numel(q),1],'real');

dL_dqdot    = simplify(jacobian(L, dq))';
dL_dqdot_dt = simplify(jacobian(dL_dqdot,[q;dq])*[dq;ddq]);
dL_dq       = simplify(jacobian((L),q))';
for i=1:numel(q)
    EL_damping(i) = -b(i)*dq(i);
end
EL_LHS      = dL_dqdot_dt - dL_dq - EL_damping;

fprintf('\t...done.\n')

%% Solving for Mass Matrix
fprintf('\tSolving for the mass matrix...\n');

M = sym('M', [numel(q), numel(q)],'real');
H = sym('H', [numel(q), 1], 'real');
C = sym('C',[numel(q),numel(q)],'real');
G = sym('G',[numel(q),1],'real');

M = simplify(jacobian(EL_LHS, ddq))
H = simplify(jacobian(dL_dqdot, q) * dq - dL_dq)

for i = 1:numel(q)
    G(i) = diff(EL_LHS(i),g)*g;
    for j = 1:numel(q)
        C(i,j) = diff((EL_LHS(i) - (M(i,:)*ddq + G(i))),dq(j));
    end
    C(i) = simplify(C(i)); 
end

fprintf('\t\t...done building M and H.\n');

fprintf('\t\tGenerating MATLAB functions...\n');
matlabFunction(M,'File','autogen_mass_matrix');
matlabFunction(H,'File','autogen_H_eom');
matlabFunction(C,'File','autogen_coriolis_matrix');
matlabFunction(G,'File','autogen_grav_vector');
fprintf('\t\t...done.\n');
%% Constraint Equations for First Bar
fprintf('\tInitializing constraint variables for first bar...\n');

% constraint variables for first bar
syms c_x c_y real

% first bar
c_x = x;
c_y = y;

C_all = [c_x; c_y];

fprintf('\t...done.\n');
fprintf('\tGenerating constraint equations for first bar...\n');

% generate MATLAB functions to compute all the constraints:
matlabFunction(C_all,'File','autogen_constraints');
fprintf('\t...done.\n');

%% Derivatives of Constraints
fprintf('\tGenerating time derivatives of the constraints...\n');

A_all = jacobian(C_all, q);
H_x = hessian(c_x, q);
H_y = hessian(c_y, q);

% generate MATLAB functions for the Jacobians and Hessians:
matlabFunction(A_all, H_x, H_y,'File','autogen_constraint_derivatives');

fprintf('\t...done.\n');
%% 
fprintf('...done deriving cart-pendulum equations.\n');

end