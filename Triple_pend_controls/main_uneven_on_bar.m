%% main.m
% Triple Pendulum


function main_uneven_on_bar

% Custom code
% simdata = double
%assignin('base','y',2)
% persistent com_x_pre;
% persistent com_y_pre;

sampleTime = 0.1;
endTime = .1;
numberOfSamples = endTime * 1/sampleTime +1;
timeVector = (0:numberOfSamples) * sampleTime;

% global com_x_pre;
% com_x_pre = 999;
% global com_y_pre;
% com_y_pre = 999;



%{
Invalid matrix variable specified as workspace input in 'simulink_controller_3/From Workspace'.
 The matrix data must be a real, double, have two dimensions, and at least two columns. The first
 column must contain time values and the remaining columns the data values.  Matrix values cannot
 be Inf or NaN.
%}

%sim('simulink_controller_3')

%% Initialize environment
clear;
close all;
clc;

init_env();

%% Initialize parameters
params = init_params;

%% Set up events using odeset
options = odeset('Events',@robot_events);

%% Simulate the robot forward in time 
x_IC = params.x_IC';    % initial conditions
tnow = 0.0;             % starting time

% start with null matrices for holding results -- we'll be adding to these
% with each segment of the simulation
tsim = [];
xsim = [];
F_list = [];
te_sim = [];
ye_sim = [];

% create a place for constraint forces
F = [];

while tnow < params.sim.tfinal

    tspan = [tnow params.sim.tfinal];
    [tseg, xseg, te, ye, ie] = ode45(@robot_dynamics, tspan, x_IC, options);

    % augment tsim and xsim; renew ICs
    tsim = [tsim;tseg];
    xsim = [xsim;xseg];
    te_sim = [te_sim; te];
    ye_sim = [ye_sim; ye];
    tnow = tsim(end);
    x_IC = xsim(end,:); 
    
    % compute the constraint forces that were active during the jump
    [Fseg] = constraint_forces_uneven(tseg,xseg',params);
    F_list = [F_list,Fseg];
    
    % if simulation terminated before tfinal, determine which constraints
    % are still active, then continue integration
    if tseg(end) < params.sim.tfinal  % termination was triggered by an event
        switch params.sim.constraints
            case ['false','false']  % The robot was not on the bar prior to termination
                 params.sim.constraints = ['false','false'];  % Now the robot is off the bar
            case ['true','true'] % The robot was on the bar prior to termination
                 params.sim.constraints = ['false','false'];  % Now the robot is off the bar
        end
    end
end

assignin('base','x2',xsim)
assignin('base','te',te_sim)

%%  Plot Results %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin with plot of ground reaction versus weight, to be sure we're
% pushing off and then leaving the ground
figure;
plot(tsim,F_list(1,:)+F_list(2,:),'b-','LineWidth',2);
hold on
weight = (params.model.dyn.top.m + params.model.dyn.mid.m + params.model.dyn.bot.m + ...
          params.model.dyn.motor1.m + params.model.dyn.motor2.m)*params.model.dyn.g*ones(1,length(tsim));
plot(tsim,weight,'r-','LineWidth',1);
ylabel('Ground Reaction vs Weight (N)')
xlabel('time (sec)')
hold off

% Now let's animate

% Let's resample the simulator output so we can animate with evenly-spaced
% points in (time,state).
% 1) deal with possible duplicate times in tsim:
% (https://www.mathworks.com/matlabcentral/answers/321603-how-do-i-interpolate-1d-data-if-i-do-not-have-unique-values
tsim = cumsum(ones(size(tsim)))*eps + tsim;

% 2) resample the duplicate-free time vector:
t_anim = 0:params.sim.dt:tsim(end);

% 3) resample the state-vs-time array:
x_anim = interp1(tsim,xsim,t_anim);
x_anim = x_anim'; % transpose so that xsim is 10xN (N = number of timesteps)

% 4) resample the constraint forces-vs-time array:
F_anim = interp1(tsim,F_list',t_anim);
F_anim = F_anim';

animate_robot_uneven(x_anim(1:10,:),F_list,params,'trace_top_com',true,...
                                                  'trace_top_tip',true,...
                                                  'trace_mid_com',true,...
                                                  'trace_mid_tip',true,...
                                                  'trace_bot_com',true,...
                                                  'trace_bot_tip',true,...
                                                  'show_constraint_forces',true,'video',true);
fprintf('Done!\n');

%% BELOW HERE ARE THE NESTED FUNCTIONS, ROBOT_DYNAMICS AND ROBOT_EVENTS
%% THEY HAVE ACCESS TO ALL VARIABLES IN MAIN

%% robot_dynamics.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Description:
%   Computes the constraint forces: 
%       Fnow = inv(A*Minv*A')*(A*Minv*(Q-H) + Adotqdot)
%
%   Also computes the derivative of the state:
%       x_dot(1:5) = (I - A'*inv(A*A')*A)*x(6:10)
%       x_dot(6:10) = inv(M)*(Q - H - A'F)
%
% Inputs:
%   t: time (scalar)
%   x: the 10x1 state vector
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   dx: derivative of state x with respect to time.

function [dx] = robot_dynamics(t,x)

% for convenience, define q_dot
dx = zeros(numel(x),1);
nq = numel(x)/2;    % assume that x = [q;q_dot];
q_dot = x(nq+1:2*nq);

% solve for control inputs at this instant
% controler
% x(3) is theta1, x(8) is theta1_dot
% set up parameters and solve for com
xx = x(1);
yy = x(2);
th1 = x(3);
th2 = x(4);
th3 = x(5);
xx_dot = x(6);
yy_dot = x(7);
th1_dot = x(8);
th2_dot = x(9);
th3_dot = x(10);

l1 = params.model.geom.top.l;
l2 = params.model.geom.mid.l;
l3 = params.model.geom.bot.l;

M1 = params.model.dyn.top.m;      % mass of the top link
M2 = params.model.dyn.mid.m;      % mass of the mid link
M3 = params.model.dyn.bot.m;      % mass of the bot link

com_l1x = xx + l1*sin(th1)/2;
com_l1y = yy - l1*cos(th1)/2;

com_l2x = com_l1x + l2*sin(th1+th2)/2;
com_l2y = com_l1y - l2*cos(th1+th2)/2;

com_l3x = com_l2x + l3*sin(th1+th2+th3)/2;
com_l3y = com_l2y - l3*cos(th1+th2+th3)/2;

com_x = (com_l1x*M1 + com_l2x*M2 + com_l3x*M3) / (M1+M2+M3);
com_y = (com_l1y*M1 + com_l2y*M2 + com_l3y*M3) / (M1+M2+M3);

% com_list(end+1) = com_y;
% assignin('base','com_list',com_list)
persistent com_y_pre
if isempty(com_y_pre)
    com_y_pre = com_y;
end
persistent com_x_pre
if isempty(com_x_pre)
    com_x_pre = com_x;
end
persistent counteri
if isempty(counteri)
    counteri = [];
end
% persistent com_y_pre;

% 
% com_x_change = com_x - com_x_pre;
com_y_change = com_y - com_y_pre;

% counteri(end+1) = com_y_change;
% assignin('base','counteri',counteri);



tau_shoulders = 0;
tau_hips = 0;
pi = 3.141;

% if (x(3)> -pi/2)   && (x(3) <-pi/4)  && (x(8) > 1) %falling botLeft1
% if (com_x < 0) &&  (com_y_change < 0)
%     tau_shoulders = 1;
%     tau_hips = 1;
% elseif (com_x > 0) && (com_y_change < 0) % falling right
%     tau_shoulders = -1;
%     tau_hips = -1;
% elseif (com_x < 0) && (com_y_change > 0) % rising left
%     tau_shoulders = -3;
%     tau_hips = -3;
%     if (th2 < -pi/2)
%         tau_shoulders = 1;
%     end
%     if (th3 < -pi/2)
%         tau_hips = 1;
%     end
%     
% elseif (com_x > 0) && (com_y_change > 0) % rising right
%     tau_shoulders = 3;
%     tau_hips = 3;
%      if (th2 > pi/2)
%         tau_shoulders = -1;
%     end
%     if (th3 > pi/2)
%         tau_hips = -1;
%     end
% end
if (th2 > pi/2) 
        tau_shoulders = -5;
elseif (th2 < -pi/2)
        tau_shoulders = 5;
end
if (th3 > pi/2)
        tau_hips = -5;
elseif (th3 < -pi/2)
        tau_hips = 5;
end

if (com_x > com_x_pre)  % moving to right
    if (com_x < 0) % falling
        tau_shoulders = 1;
        tau_hips = 1;
    else % rising
        tau_shoulders = 3;
        tau_hips = 3;
    end
     
else
    if (com_x > 0) % falling
        tau_shoulders = -1;
        tau_hips = -1;
    else % rising
        tau_shoulders = -3;
        tau_hips = -3;
    end
    
end


%     if (x(4) >= -.5)
%         tau_shoulders = 0;
%     else
%         tau_shoulders = 0
%     end
%     if (x(5) >= -.5)
%         tau_hips = .6;
%     else
%         tau_hips = 1
%     end
% elseif (x(3)<0) && (x(3)>-pi/4) && (x(8) > 1) %falling botLeft2
%     if (x(4) >= -.5)
%         tau_shoulders = 0;
%     else
%         tau_shoulders = 0
%     end
%     if (x(5) >= -.5)
%         tau_hips = .3;
%     else
%         tau_hips = 1
%     end
% elseif (x(3)>pi/4) && (x(3) <pi/2)  && (x(8) < 1) %falling botRight1
%     if (x(4) <= 0.5)
%         tau_shoulders = 0;
%     else
%         tau_shoulders = 0
%     end
%     if (x(5) <= 0.5)
%         tau_hips = -.6;
%     else
%         tau_hips = -1
%     end
% elseif (x(3)<pi/4) && (x(3)>0) && (x(8) < 1) %falling botRight2
%      if (x(4) <= 0.5)
%         tau_shoulders = 0;
%     else
%         tau_shoulders = 0
%     end
%     if (x(5) <= 0.5)
%         tau_hips = .3;
%     else
%         tau_hips = -1
%     end
% elseif (x(3)<pi/4) && (x(3)>=0) && (x(8) >= 1) %rising botRight1
%     tau_shoulders = 5;
%     tau_hips = 5; 
% elseif (x(3)<pi/2) && (x(3)>pi/4) && (x(8) > 1) %rising botRight2
%     tau_shoulders = 5;
%     tau_hips = 5;
% elseif (x(3)<0) && (x(3)>-pi/4) && (x(8) < -1) %rising botLeft1
%     tau_shoulders = -5;
%     tau_hips = -5; 
% elseif (x(3)<-pi/4) && (x(3)>-pi/2) && (x(8) < -1) %rising botLeft2
%     tau_shoulders = -5;
%     tau_hips = -5;
% end

com_x_pre = com_x;
com_y_pre = com_y;

Q = [0; 0; 0; tau_shoulders; tau_hips];

% find the parts that don't depend on constraint forces

% H matrix
H = H_eom(x,params);

% 5x5 Mass Matrix
M = mass_matrix_uneven(x, params);

% 5x5 Coriolis Matrix
C = coriolis_matrix_uneven(x, params);

% 5x1 Grav Vector
G = grav_vector_uneven(x, params);

% 5x2 Selection Matrix
S = [0,0;
     0,0;
     0,0;
     1,0;
     0,1];

% 5x5 Inverse Mass Matrix
Minv = inv(M);

% function that returns A matrix and Hessians
[A_all,Hessian] = constraint_derivatives(x,params);

% function that returns drift vector field and control vector field
% [f_ss, g_ss] = state_space(x, Minv, C, G, S);

% TRYING TO RELEASE FROM BAR
% xx = x(1);
% yy = x(2);
% th1 = x(3);
% th2 = x(4);
% th3 = x(5);

% l1 = params.model.geom.top.l;
% l2 = params.model.geom.mid.l;
% l3 = params.model.geom.bot.l;

p1_x = xx + l1*sin(th1);
p1_y = yy - l1*cos(th1);

p2_x = p1_x + l2*sin(th1+th2);
p2_y = p1_y - l2*cos(th1+th2);

p3_x = p2_x + l3*sin(th1+th2+th3);
p3_y = p2_y - l3*cos(th1+th2+th3);

%if (p1_x < params.sim.bar1.x) && (p2_x < params.sim.bar1.x) && (p3_x < params.sim.bar1.x)
    s = ['true', 'true'];
    A = A_all([1,2],:);
    Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                q_dot'*Hessian(:,:,2)*q_dot];
    Fnow = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);
    dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
    dx(nq+1:2*nq) = Minv*(Q - H - A'*Fnow);
    F = [Fnow(1); Fnow(2)];

%{
elseif (params.sim.bar1.x < p1_x < params.sim.bar2.x) &&...
       (params.sim.bar1.x < p2_x < params.sim.bar2.x) &&...
       (params.sim.bar1.x < p3_x < params.sim.bar2.x)
    s = ['false', 'false'];
    dx(1:nq) = q_dot;
    dx(nq+1:2*nq) = Minv*(Q - H);
    F = [0;0]; 
elseif (params.sim.bar2.x < p1_x) &&...
       (params.sim.bar2.x < p2_x) &&...
       (params.sim.bar2.x < p3_x)
    s = ['true', 'true'];
    A = A_all([1,2],:);
    Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                q_dot'*Hessian(:,:,2)*q_dot];
    Fnow = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);
    dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
    dx(nq+1:2*nq) = Minv*(Q - H - A'*Fnow);
    F = [Fnow(1); Fnow(2)];
end
%}
    
end
%% end of robot_dynamics.m


%% Event function for ODE45 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Description:
%   Event function that is called when a constraint becomes inactive (or, in the future, active) 
%
% Inputs:
%   t and x are required, but not used
%   F is shared with parent function
%
% Outputs:
%   value
%   isterminal
%   direction
function [value,isterminal,direction] = robot_events(t,x)
    switch params.sim.constraints  
        case ['false','false'] % robot is off the bar
            value = 1;
            isterminal = 0;
            direction = 0;
        case ['true','true'] % robot is on the bar
            value = [F(1); F(2)];
            isterminal = ones(2,1);
            direction = zeros(2,1);
    end

end
%% end of robot_events.m 
end
%% End of main.m

