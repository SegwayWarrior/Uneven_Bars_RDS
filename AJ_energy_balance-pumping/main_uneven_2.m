%% main_uneven.m
% Triple Pendulum

function main_uneven

%% Initialize environment
clear;
close all;
clc;

init_env();

%% Initialize parameters
params = init_params;

%% Set up events using odeset
options = odeset('RelTol',1e-6,'AbsTol',1e-6,'Events', @(t,x) robot_events(t,x));

%% Simulate the robot forward in time 
x_IC = params.x_IC';    % initial conditions
tnow = 0.0;             % starting time

% start with null matrices for holding results -- we'll be adding to these
% with each segment of the simulation
tsim = [];
xsim = [];
F_list = [];
te_sim = [];
ye_sim = [];

% create a place for constraint forces
F = [];

while tnow < params.sim.tfinal

    tspan = [tnow params.sim.tfinal];
    TE = total_energy(x_IC,params);
    [tseg, xseg, te, ye, ie] = ode45(@robot_dynamics, tspan, x_IC, options);
   
    tsim = [tsim;tseg]; % augment simulation time 
    xsim = [xsim;xseg]; % augment simulation states
    te_sim = [te_sim; te]; % augment event time
    ye_sim = [ye_sim; ye]; % augment location of events
    tnow = tsim(end); % updates time
    x_IC = xsim(end,:); % renew initial conditions
    
    % compute the constraint forces that were active
    [Fseg] = constraint_forces_uneven(tseg,xseg',params);
    F_list = [F_list,Fseg];
    
    % if simulation terminated before tfinal, determine which constraints
    % are still active, then continue integration
    if tseg(end) < params.sim.tfinal  % termination was triggered by an event
        switch params.sim.constraints
            case ['pumping'] % The robot is pumping up for Giant Swing
                params.sim.constraints = ['bar1'] % Finish giant swing on bar 1 
            case ['bar1']  % The robot is on bar 1 prior to termination
                params.sim.constraints = ['flight']; % Robot releases from bar 1 and is in flight
            case ['flight'] % The robot is in flight prior to termination
                % solves for dq at time t+ right after impact
                dq_plus = collision(tseg(end), xseg(end,:)', params);
                % renew initial conditions
                x_IC(6:10) = dq_plus;
                params.sim.constraints = ['bar2']; % The robot catches bar 2
        end
    end
end

%%  Plot Results %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin with plot of ground reaction versus weight, to be sure we're
% pushing off and then leaving the ground
%{
figure;
plot(tsim,F_list(1,:)+F_list(2,:),'b-','LineWidth',2);
hold on
weight = (params.model.dyn.top.m + params.model.dyn.mid.m + params.model.dyn.bot.m + ...
          params.model.dyn.motor1.m + params.model.dyn.motor2.m)*params.model.dyn.g*ones(1,length(tsim));
plot(TE,'r-','LineWidth',1);
ylabel('Ground Reaction vs Weight (N)')
xlabel('time (sec)')
hold off
%}
% Now let's animate

% 1) deal with possible duplicate times in tsim:
tsim = cumsum(ones(size(tsim)))*eps + tsim;

% 2) resample the duplicate-free time vector:
t_anim = 0:params.viz.dt:tsim(end);

% 3) resample the state-vs-time array:
x_anim = interp1(tsim,xsim,t_anim);
x_anim = x_anim'; % transpose so that x_anim is 10xN (N = number of timesteps)

% 4) resample the constraint forces-vs-time array:
F_anim = interp1(tsim,F_list',t_anim);
F_anim = F_anim'; % transpose so that F_anim is 10xN (N = number of timesteps)

animate_robot_uneven(x_anim(1:10,:),F_anim,params,'trace_top_com',false,...
                                                  'trace_top_tip',false,...
                                                  'trace_mid_com',false,...
                                                  'trace_mid_tip',false,...
                                                  'trace_bot_com',false,...
                                                  'trace_bot_tip',false,...
                                                  'show_constraint_forces',false,...
                                                  'video',true);
                                              
fprintf('Done!\n');

%% BELOW HERE ARE THE NESTED FUNCTIONS, ROBOT_DYNAMICS AND ROBOT_EVENTS
%% THEY HAVE ACCESS TO ALL VARIABLES IN MAIN

%% robot_dynamics.m %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Description: 
%   Computes constraint forces (Fnow =
%   inv(A*Minv*A')*(A*Minv*(Q-H) + Adotqdot) and impacts (delta_dq =
%   -Minv*A'*inv(A*Minv*A')*(1+eps)*A*q_dot;)
%
%   Also computes the derivative of the state:
%       x_dot(1:5) = (I - A'*inv(A*A')*A)*x(6:10)
%       x_dot(6:10) = inv(M)*(Q - H - A'F)
%
% Inputs:
%   t: time (scalar)
%   x: the 10x1 state vector
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   dx: derivative of state x with respect to time.

function [dx] = robot_dynamics(t,x)

% for convenience, define q_dot
dx = zeros(numel(x),1);
nq = numel(x)/2;    % assume that x = [q;q_dot];
q_dot = x(nq+1:2*nq);

% H matrix
H = H_eom(x,params);

% 5x5 Mass Matrix
M = mass_matrix_uneven(x, params);

% 5x5 Coriolis Matrix
C = coriolis_matrix_uneven(x, params);

% 5x1 Grav Vector
G = grav_vector_uneven(x, params);

% 5x2 Selection Matrix
S = [0,0;
     0,0;
     0,0;
     1,0;
     0,1];

% 5x5 Inverse Mass Matrix
Minv = inv(M);
%

%%ENERGY SHAPING AJ SHIT%%
% functions that return kinetic energy, potential energy and total energy
KE = kinetic_energy(x,params);
PE = potential_energy(x,params);
TE = total_energy(x,params);

Edes = 294.0000 ; %pumping,
Eerr= TE - Edes;
%RANDOM TUNABLE VALUES
k21 = 01;
k22 = 01;
k23 = 1000;
k31 = 01;
k32 = 01;
k33 = 1000;
Kb = [k21 0 k22 0;0 k31 0 k32]; %2X4 MATRIX 
K2 = [k23*Eerr*x(9);k33*Eerr*x(10)]; %need to verify if x9 and x10 used correctly
X49 = [x(4); x(5);x(9); x(10)];
[ddqa12] = (-(Kb)*(X49))+K2;
ddqa1 = ddqa12(1,1);
ddqa2 = ddqa12(2,1);
ddqu = -([M(3,4),M(3,5)]*[ddqa12] +C(3,3)*x(8)+ [C(3,4),C(3,5)]*[x(9);x(10)]+ G(3,1))/M(3,3);
%ddqu = 0;  %%TO PUT RELEVANT VALUE
%{
%APPROACH 1
%EQUATION 3b
Tau1 = M(4,3)*(ddqa1)+ M(4,4)*(ddqa1)+ M(4,5)*(ddqa2)+ C(4,3)*x(9)+ C(4,4)*x(9)+C(4,5)*x(10)+G(2,1);
%EQUATION 3c
Tau2 = M(5,3)*(ddqa2)+ M(5,4)*(ddqa1)+ M(5,5)*(ddqa2)+ C(5,3)*x(10)+ C(5,4)*x(9)+ C(5,5)*x(10)+ G(3,1);
% END OF APPROACH 1
%}
%{
%APPROACH 2
M3 = [M(3,3) M(3,4) M(3,5);M(4,3) M(4,4) M(4,5);M(5,3) M(5,4) M(5,5)];
C3 = [C(3,3) C(3,4) C(3,5);C(4,3) C(4,4) C(4,5);C(5,3) C(5,4) C(5,5)];
G3 = [G(3,1);G(4,1);G(5,1)];
[ut1t2] = M3*[ddqu;ddqa1;ddqa2]+ C3*[x(8);x(9);x(10)]+ G3;
%u = ut1t2(1,1);
Tau1 = ut1t2(2,1);
Tau2 = ut1t2(3,1);
%END OF APPROACH 2
%}
%APPROACH 3
mA = ([M(4,4), M(4,5);M(5,4),M(5,5)]-([M(4,3);M(5,3)]*[M(3,4),M(3,5)])/M(3,3)); %confirm first M
mB = [M(4,3);M(5,3)]/M(3,3);
cC = (C(3,3)*x(8) + [C(3,4),C(3,5)]*[x(9);x(10)] + G(3,1));
cD = [C(4,3);C(5,3)]*x(8) + [C(4,4),C(4,5);C(5,4),C(5,5)]*[x(9);x(10)] + [G(4,1);G(5,1)];
T = mA*ddqa12 - mB*cC + cD;
Tau1 = T(1,1);
Tau2 = T(2,1);
%END OF APPROACH 3

% torque applied at shoulders
%tau_shoulders = t1;
% torque applied at hips
%tau_hips = t2;
% 5x1 Q column vector
Q = [0;0;0;Tau1;Tau2];
Q';


%%TRIAL AND DEBUGGING COMMENT WHOLE SECTION OUT
%Q = [0;0;0;0;0];
%{
x(9)
x(10)
x(4)
x(5)
%%END OF TRIAL SECTION
%}

%%END OF ENERGY SHAPING AJ SHIT%%

% function that returns A matrix and Hessians
[A_all,Hessian] = constraint_derivatives(x,params);
% function that returns drift vector field and control vector field
[f_ss, g_ss] = state_space(x, Minv, C, G, S);


%{
% solves for current robot state
xx = x(1);
yy = x(2);
th1 = x(3);
th2 = x(4);
th3 = x(5);
xx_dot = x(6);
yy_dot = x(7);
th1_dot = x(8);
th2_dot = x(9);
th3_dot = x(10);

% length of each link
l1 = params.model.geom.top.l;
l2 = params.model.geom.mid.l;
l3 = params.model.geom.bot.l;

% mass of each link
M1 = params.model.dyn.top.m;
M2 = params.model.dyn.mid.m;
M3 = params.model.dyn.bot.m;

% length of each link CoM
r1 = params.model.dyn.top.r_com;
r2 = params.model.dyn.mid.r_com;
r3 = params.model.dyn.bot.r_com;

% (x,y) location of top link CoM
com_l1x = xx + r1*sin(th1);
com_l1y = yy - r1*cos(th1);

% (x,y) location of mid link CoM
com_l2x = com_l1x + r2*sin(th1+th2);
com_l2y = com_l1y - r2*cos(th1+th2);

% (x,y) location of bot link CoM
com_l3x = com_l2x + r3*sin(th1+th2+th3);
com_l3y = com_l2y - r3*cos(th1+th2+th3);

% (x,y) location of robot CoM
com_x = (com_l1x*M1 + com_l2x*M2 + com_l3x*M3) / (M1+M2+M3);
com_y = (com_l1y*M1 + com_l2y*M2 + com_l3y*M3) / (M1+M2+M3);

% (x,y) location of top link tip
p1_x = xx + l1*sin(th1);
p1_y = yy - l1*cos(th1);

% (x,y) location of mid link tip
p2_x = p1_x + l2*sin(th1+th2);
p2_y = p1_y - l2*cos(th1+th2);

% (x,y) location of bot link tip
p3_x = p2_x + l3*sin(th1+th2+th3);
p3_y = p2_y - l3*cos(th1+th2+th3);
%}
switch params.sim.constraints
    case ['pumping'] % robot is pumping
        % solves for constraint forces active when robot is pumping
        A = A_all([1,2],:);
        Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                    q_dot'*Hessian(:,:,2)*q_dot ];
        Fnow = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);
        dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
        dx(nq+1:2*nq) = Minv*(Q - H - A'*Fnow);
        F = [Fnow(1); Fnow(2)];
    case ['bar1'] % robot is on bar 1
        % solves for constraint forces active
        A = A_all([1,2],:);
        Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                    q_dot'*Hessian(:,:,2)*q_dot ];
        Fnow = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);
        dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
        dx(nq+1:2*nq) = Minv*(Q - H - A'*Fnow);
        F = [Fnow(1); Fnow(2)];
    case ['flight'] % robot is in flight
        % no constraint forces present
        dx(1:nq) = q_dot;
        dx(nq+1:2*nq) = Minv*(Q - H);
        F = [0;0];
    case ['bar2'] % robot is on bar 2
        % solves for constraint forces
        A = A_all([1,2],:);
        Adotqdot = [q_dot'*Hessian(:,:,1)*q_dot;
                    q_dot'*Hessian(:,:,2)*q_dot ];
        Fnow = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);
        dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
        dx(nq+1:2*nq) = Minv*(Q - H - A'*Fnow);
        F = [Fnow(1); Fnow(2)];
end

end
%% end of robot_dynamics.m

%% Event function for ODE45 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Description:
%   Event function that is called when a constraint becomes inactive (or, in the future, active) 

% Inputs:
%   t and x are required, but not used
%   F is shared with parent function

% Outputs:
%   value
%   isterminal
%   direction
function [value,isterminal,direction] = robot_events(t,x)
    % solves for current robot state
    xx = x(1);
    yy = x(2);
    th1 = x(3);
    th2 = x(4);
    th3 = x(5);
    
    % length of each link
    l1 = params.model.geom.top.l;
    l2 = params.model.geom.mid.l;
    l3 = params.model.geom.bot.l;
    
    % (x,y) location of top link tip
    p1_x = xx + l1*sin(th1);
    p1_y = yy - l1*cos(th1);

    % (x,y) location of mid link tip
    p2_x = p1_x + l2*sin(th1+th2);
    p2_y = p1_y - l2*cos(th1+th2);

    % (x,y) location of bot link tip
    p3_x = p2_x + l3*sin(th1+th2+th3);
    p3_y = p2_y - l3*cos(th1+th2+th3);

    switch params.sim.constraints
        case ['pumping'] % robot is pumping up to Giant Swing
            value = 1;
            isterminal = 0;
            direction = 0;
%             % if the robot is along positive y-axis
%             value = [p1_x - params.sim.bar1.x;
%                      p1_y - (params.sim.bar1.y + l1);
%                      p2_x - params.sim.bar1.x;
%                      p2_y - (params.sim.bar1.y + l1 + l2);
%                      p3_x - params.sim.bar1.x;
%                      p3_y - (params.sim.bar1.y + l1 + l2 + l3)];
%             % terminate integration (trigger event)
%             isterminal = 1;
%             % positive or negative direction
%             direction = 0;
        case ['bar1'] % robot is on bar 1
            % if the x location of second pendulum = x location of bar 1
            value = p2_x - params.sim.bar1.x;
            % terminate integration (trigger event)
            isterminal = 1;
            % positive or negative direction
            direction = 0;
        case ['flight'] % robot is in flight
            % if the x location of the gripper = x location of bar 2
            value = abs(xx) - params.sim.bar2.x;
            % terminate integration (trigger event)
            isterminal = 1;
            % positive or negative direction
            direction = 0;
        case ['bar2'] % robot is on bar 2
            % always true
            value = 1;
            % continue integration (no event triggered)
            isterminal = 0;
            % positive or negative direction
            direction = 0;
    end
end
%% end of robot_events.m 
end
%% End of main.m